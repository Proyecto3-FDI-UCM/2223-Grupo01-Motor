.TH "me::RenderManager" 3 "Mon Apr 3 2023" "Version 0.2.1" "MotorEngine" \" -*- nroff -*-
.ad l
.nh
.SH NAME
me::RenderManager
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <RenderManager\&.h>\fP
.PP
Inherits \fBme::Singleton< RenderManager >\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBRenderManager\fP & \fBoperator=\fP (const \fBRenderManager\fP &o)=delete"
.br
.ti -1c
.RI "\fBRenderManager\fP (const \fBRenderManager\fP &o)=delete"
.br
.ti -1c
.RI "\fB~RenderManager\fP () override"
.br
.ti -1c
.RI "bool \fBcreateCamera\fP (std::string name, std::string parentName, int nearDist, int farDist, bool autoRadio, int zOrder, Ogre::ColourValue color=Ogre::ColourValue(0, 0, 0, 1))"
.br
.ti -1c
.RI "bool \fBcreateCamera\fP (std::string name, int nearDist, int farDist, bool autoRadio, int zOrder, Ogre::ColourValue color=Ogre::ColourValue(0, 0, 0, 1))"
.br
.ti -1c
.RI "bool \fBsetCameraInfo\fP (std::string name, const \fBOgre::Vector3f\fP &pos, const \fBOgre::Vector3f\fP &look)"
.br
.ti -1c
.RI "bool \fBsetViewportDimension\fP (std::string name, float left, float top, float width, float height)"
.br
.ti -1c
.RI "void \fBdestroyCamera\fP (std::string name)"
.br
.ti -1c
.RI "void \fBcreateNewLight\fP (std::string name, const \fBOgre::Vector3f\fP &pos, const \fBOgre::Vector3f\fP &dir)"
.br
.ti -1c
.RI "bool \fBcreateMesh\fP (std::string name, std::string nameMesh)"
.br
.ti -1c
.RI "bool \fBsetMeshTransform\fP (std::string name, \fBVector3\fP pos, \fBVector3\fP scale)"
.br
.ti -1c
.RI "bool \fBsetMeshTransform\fP (std::string name, \fBVector3\fP pos, \fBVector3\fP scale, \fBVector4\fP rot)"
.br
.ti -1c
.RI "bool \fBsetMeshPosition\fP (std::string name, \fBVector3\fP pos)"
.br
.ti -1c
.RI "bool \fBsetMeshScale\fP (std::string name, \fBVector3\fP scale)"
.br
.ti -1c
.RI "bool \fBsetMeshRotation\fP (std::string name, \fBVector4\fP rot)"
.br
.ti -1c
.RI "bool \fBsetMeshMaterial\fP (std::string name, std::string nameMaterial)"
.br
.ti -1c
.RI "void \fBdestroyMesh\fP (std::string name)"
.br
.ti -1c
.RI "bool \fBcreateParticle\fP (std::string name, std::string nameMesh)"
.br
.ti -1c
.RI "bool \fBsetParticleTransform\fP (std::string name, \fBVector3\fP pos, \fBVector3\fP scale)"
.br
.ti -1c
.RI "bool \fBsetParticleTransform\fP (std::string name, \fBVector3\fP pos, \fBVector3\fP scale, \fBVector4\fP rot)"
.br
.ti -1c
.RI "bool \fBsetParticlePosition\fP (std::string name, \fBVector3\fP pos)"
.br
.ti -1c
.RI "bool \fBsetParticleScale\fP (std::string name, \fBVector3\fP scale)"
.br
.ti -1c
.RI "bool \fBsetParticleRotation\fP (std::string name, \fBVector4\fP rot)"
.br
.ti -1c
.RI "bool \fBsetParticleEmitting\fP (std::string name, bool emitted)"
.br
.ti -1c
.RI "Ogre::SceneNode * \fBcreateNode\fP (std::string name)"
.br
.ti -1c
.RI "Ogre::SceneNode * \fBcreateChildNode\fP (std::string name, std::string parent)"
.br
.ti -1c
.RI "\fBRenderWindow\fP * \fBgetOgreWindow\fP ()"
.br
.ti -1c
.RI "Ogre::SceneNode * \fBgetRootSceneNode\fP ()"
.br
.ti -1c
.RI "void \fBscene1\fP ()"
.br
.ti -1c
.RI "void \fBrender\fP ()"
.br
.ti -1c
.RI "Ogre::Entity * \fBgetOgreEntity\fP (std::string name)"
.br
.ti -1c
.RI "Ogre::TextAreaOverlayElement * \fBcreateOverlayElement\fP ()"
.br
.ti -1c
.RI "Ogre::SceneManager * \fBgetSceneManager\fP ()"
.br
.in -1c

Public Member Functions inherited from \fBme::Singleton< RenderManager >\fP
.in +1c
.ti -1c
.RI "\fBSingleton\fP (const \fBSingleton\fP< \fBRenderManager\fP > &o)=delete"
.br
.ti -1c
.RI "\fBSingleton\fP< \fBRenderManager\fP > & \fBoperator=\fP (const \fBSingleton\fP< \fBRenderManager\fP > &o)=delete"
.br
.ti -1c
.RI "virtual \fB~Singleton\fP ()"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBinitRoot\fP ()"
.br
.ti -1c
.RI "void \fBinitWindow\fP ()"
.br
.ti -1c
.RI "void \fBlocateResources\fP ()"
.br
.ti -1c
.RI "void \fBloadResources\fP ()"
.br
.ti -1c
.RI "bool \fBinitialiseRTShaderSystem\fP ()"
.br
.ti -1c
.RI "\fBRenderCamera\fP * \fBgetCamera\fP (std::string name)"
.br
.ti -1c
.RI "\fBRenderMesh\fP * \fBgetMesh\fP (std::string name)"
.br
.ti -1c
.RI "\fBRenderParticleSystem\fP * \fBgetParticle\fP (std::string name)"
.br
.in -1c

Protected Member Functions inherited from \fBme::Singleton< RenderManager >\fP
.in +1c
.ti -1c
.RI "\fBSingleton\fP ()"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "Ogre::Root * \fBmRoot\fP"
.br
.ti -1c
.RI "Ogre::SceneManager * \fBmSM\fP = nullptr"
.br
.ti -1c
.RI "Ogre::AnimationState * \fBogreAnimState\fP"
.br
.ti -1c
.RI "std::string \fBmResourceCfgPath\fP"
.br
.ti -1c
.RI "std::string \fBmPluginCfgPath\fP"
.br
.ti -1c
.RI "OverlayManager * \fBmOverlayManager\fP"
.br
.ti -1c
.RI "std::string \fBmOgreCfgPath\fP"
.br
.ti -1c
.RI "Ogre::FileSystemLayer * \fBmFSLayer\fP"
.br
.ti -1c
.RI "Ogre::RTShader::ShaderGenerator * \fBmShaderGenerator\fP"
.br
.ti -1c
.RI "\fBSGTechniqueResolverListener\fP * \fBmMaterialMgrListener\fP"
.br
.ti -1c
.RI "std::string \fBmSolutionPath\fP"
.br
.ti -1c
.RI "\fBRenderWindow\fP * \fBmOgreWindow\fP"
.br
.ti -1c
.RI "std::unordered_map< std::string, \fBRenderCamera\fP * > \fBmCameras\fP"
.br
.ti -1c
.RI "std::unordered_map< std::string, \fBRenderMesh\fP * > \fBmMeshes\fP"
.br
.ti -1c
.RI "std::unordered_map< std::string, \fBRenderParticleSystem\fP * > \fBmParticles\fP"
.br
.in -1c
.SS "Additional Inherited Members"


Static Public Member Functions inherited from \fBme::Singleton< RenderManager >\fP
.in +1c
.ti -1c
.RI "static \fBRenderManager\fP * \fBinit\fP (Targs &&\&.\&.\&.args)"
.br
.ti -1c
.RI "static \fBRenderManager\fP * \fBinstance\fP ()"
.br
.in -1c
.SH "Detailed Description"
.PP 
OgreManager initialize \fBOgre\fP (Root, RTShaderSystem, \fBSceneManager\fP, \fBRenderWindow\fP), locate and load resources (from resource\&.cfg) and handle the creation of camera, light, mesh You can access the OgreManager just calling om()\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "me::RenderManager::RenderManager (const \fBRenderManager\fP & o)\fC [delete]\fP"

.SS "me::RenderManager::~RenderManager ()\fC [override]\fP"

.SH "Member Function Documentation"
.PP 
.SS "bool me::RenderManager::createCamera (std::string name, int nearDist, int farDist, bool autoRadio, int zOrder, Ogre::ColourValue color = \fCOgre::ColourValue(0, 0, 0, 1)\fP)"
Create the camera with this name and store it 
.PP
\fBParameters\fP
.RS 4
\fIname\fP name of camera 
.br
\fInearDist\fP near clipping plane distancia 
.br
\fIfarDist\fP far clipping plane distancia 
.br
\fIautoRadio\fP if viewport calculate aspect radio automatically 
.br
\fIzOrder\fP relative order of viewport 
.RE
.PP
\fBReturns\fP
.RS 4
false: if renamed 
.PP
true: if succeed 
.RE
.PP

.SS "bool me::RenderManager::createCamera (std::string name, std::string parentName, int nearDist, int farDist, bool autoRadio, int zOrder, Ogre::ColourValue color = \fCOgre::ColourValue(0, 0, 0, 1)\fP)"
Create the camera that is a child of another Ogre::SceneNode with this name and store it 
.PP
\fBParameters\fP
.RS 4
\fIname\fP name of camera 
.br
\fIparentName\fP name of parent Ogre::SceneNode 
.br
\fInearDist\fP near clipping plane distancia 
.br
\fIfarDist\fP far clipping plane distancia 
.br
\fIautoRadio\fP if viewport calculate aspect radio automatically 
.br
\fIzOrder\fP relative order of viewport 
.RE
.PP
\fBReturns\fP
.RS 4
false: if renamed 
.PP
true: if succeed 
.RE
.PP

.SS "Ogre::SceneNode * me::RenderManager::createChildNode (std::string name, std::string parent)"

.PP
\fBParameters\fP
.RS 4
\fIname\fP name of node 
.br
\fIparent\fP name of parent node 
.RE
.PP
\fBReturns\fP
.RS 4
Ogre::SceneNodo created with this name and it is child node of another node 
.RE
.PP

.SS "bool me::RenderManager::createMesh (std::string name, std::string nameMesh)"
Create the ogreMesh with this name 
.PP
\fBParameters\fP
.RS 4
\fIname\fP name of Ogre::SceneNode &&unordered_map 
.br
\fInameMesh\fP name of file (xxx\&.mesh) 
.RE
.PP
\fBReturns\fP
.RS 4
false: if renamed 
.PP
true: if succeed 
.RE
.PP

.SS "void me::RenderManager::createNewLight (std::string name, const \fBOgre::Vector3f\fP & pos, const \fBOgre::Vector3f\fP & dir)"
Create the light with this name 
.PP
\fBParameters\fP
.RS 4
\fIname\fP name of light 
.br
\fIpos\fP position of light 
.br
\fIdir\fP direction of light 
.RE
.PP

.SS "Ogre::SceneNode * me::RenderManager::createNode (std::string name)"

.PP
\fBParameters\fP
.RS 4
\fIname\fP name of node 
.RE
.PP
\fBReturns\fP
.RS 4
Ogre::SceneNodo created with this name and it is in root node 
.RE
.PP

.SS "Ogre::TextAreaOverlayElement * me::RenderManager::createOverlayElement ()"

.SS "bool me::RenderManager::createParticle (std::string name, std::string nameMesh)"
Create the ogreParticleSystem with this name 
.PP
\fBParameters\fP
.RS 4
\fIname\fP name of Ogre::SceneNode &&unordered_map 
.br
\fInameParticle\fP name of partcile system that is written int ParticleResource\&.particle 
.RE
.PP
\fBReturns\fP
.RS 4
false: if renamed 
.PP
true: if succeed 
.RE
.PP

.SS "void me::RenderManager::destroyCamera (std::string name)"

.SS "void me::RenderManager::destroyMesh (std::string name)"

.SS "\fBRenderCamera\fP * me::RenderManager::getCamera (std::string name)\fC [protected]\fP"

.PP
\fBParameters\fP
.RS 4
\fIname\fP Name of the camera 
.RE
.PP
\fBReturns\fP
.RS 4
OgreCamera: that was created with this name 
.PP
nullptr: if it doesn't exist 
.RE
.PP

.SS "\fBRenderMesh\fP * me::RenderManager::getMesh (std::string name)\fC [protected]\fP"

.PP
\fBParameters\fP
.RS 4
\fIname\fP Name of the mesh 
.RE
.PP
\fBReturns\fP
.RS 4
OgreMesh: that was created with this name 
.PP
nullptr: if it doesn't exist 
.RE
.PP

.SS "Ogre::Entity * me::RenderManager::getOgreEntity (std::string name)"
Return the Ogre::Entity asociated 
.SS "\fBRenderWindow\fP * me::RenderManager::getOgreWindow ()"
Returns a pointer to the OgreWindow used for rendering\&. 
.PP
\fBReturns\fP
.RS 4
The Render \fBWindow\fP 
.RE
.PP

.SS "\fBRenderParticleSystem\fP * me::RenderManager::getParticle (std::string name)\fC [protected]\fP"

.PP
\fBParameters\fP
.RS 4
\fIname\fP Name of the particle 
.RE
.PP
\fBReturns\fP
.RS 4
OgreParticleSystem: that was created with this name 
.PP
nullptr: if it doesn't exist 
.RE
.PP

.SS "Ogre::SceneNode * me::RenderManager::getRootSceneNode ()"
Returns a pointer to the Root SceneNode\&. 
.PP
\fBReturns\fP
.RS 4
returns the root scene node 
.RE
.PP

.SS "Ogre::SceneManager * me::RenderManager::getSceneManager ()"

.SS "bool RenderManager::initialiseRTShaderSystem ()\fC [protected]\fP"
initialize RTShaderSystem (Shader Generator) and add \fBOgre\fP:: Material Manager Listener 
.SS "void RenderManager::initRoot ()\fC [protected]\fP"
initializes FileSystem, find m_Paths and initialize Ogre::Root 
.SS "void me::RenderManager::initWindow ()\fC [protected]\fP"
Creates OgreWindow (\fBRenderWindow\fP) 
.SS "void RenderManager::loadResources ()\fC [protected]\fP"
Call Ogre::ResourceGroupManager to load added resources 
.SS "void RenderManager::locateResources ()\fC [protected]\fP"

.SS "\fBRenderManager\fP & me::RenderManager::operator= (const \fBRenderManager\fP & o)\fC [delete]\fP"

.SS "void me::RenderManager::render ()"
Render one frame of Ogre::Root -> current scene manager 
.SS "void me::RenderManager::scene1 ()"
Example scene where rendering a sinbad with 2 camera,viewport 
.SS "bool me::RenderManager::setCameraInfo (std::string name, const \fBOgre::Vector3f\fP & pos, const \fBOgre::Vector3f\fP & look)"
Set location and direction to the camera with this name 
.PP
\fBParameters\fP
.RS 4
\fIname\fP name of camera 
.br
\fIpos\fP position of camera 
.br
\fIlook\fP camera look at 
.RE
.PP
\fBReturns\fP
.RS 4
false: if it doesn't exist 
.PP
true: if succeed 
.RE
.PP

.SS "bool me::RenderManager::setMeshMaterial (std::string name, std::string nameMaterial)"

.SS "bool me::RenderManager::setMeshPosition (std::string name, \fBVector3\fP pos)"

.SS "bool me::RenderManager::setMeshRotation (std::string name, \fBVector4\fP rot)"

.SS "bool me::RenderManager::setMeshScale (std::string name, \fBVector3\fP scale)"

.SS "bool me::RenderManager::setMeshTransform (std::string name, \fBVector3\fP pos, \fBVector3\fP scale)"
Set \fBTransform\fP info to the mesh with this name (for static object) 
.PP
\fBParameters\fP
.RS 4
\fIname\fP name of ogreMesh 
.br
\fIpos\fP position of ogreMesh 
.br
\fIscale\fP scale of ogreMesh 
.RE
.PP
\fBReturns\fP
.RS 4
false: if it doesn't exist 
.PP
true: if succeed 
.br
 
.RE
.PP

.SS "bool me::RenderManager::setMeshTransform (std::string name, \fBVector3\fP pos, \fBVector3\fP scale, \fBVector4\fP rot)"

.SS "bool me::RenderManager::setParticleEmitting (std::string name, bool emitted)"

.SS "bool me::RenderManager::setParticlePosition (std::string name, \fBVector3\fP pos)"

.SS "bool me::RenderManager::setParticleRotation (std::string name, \fBVector4\fP rot)"

.SS "bool me::RenderManager::setParticleScale (std::string name, \fBVector3\fP scale)"

.SS "bool me::RenderManager::setParticleTransform (std::string name, \fBVector3\fP pos, \fBVector3\fP scale)"
Set \fBTransform\fP info to the particle with this name (for static object) 
.PP
\fBParameters\fP
.RS 4
\fIname\fP name of ogreParticleSystem 
.br
\fIpos\fP position of ogreParticleSystem 
.br
\fIscale\fP scale of ogreParticleSystem 
.RE
.PP
\fBReturns\fP
.RS 4
false: if it doesn't exist 
.PP
true: if succeed 
.RE
.PP

.SS "bool me::RenderManager::setParticleTransform (std::string name, \fBVector3\fP pos, \fBVector3\fP scale, \fBVector4\fP rot)"

.SS "bool me::RenderManager::setViewportDimension (std::string name, float left, float top, float width, float height)"
Set dimension to the viewport of the camera with this name 
.PP
\fBParameters\fP
.RS 4
\fIname\fP name of camera 
.br
\fIleft\fP left point of viewport in range 0\&.0 to 1\&.0 
.br
\fItop\fP top point of viewport in range 0\&.0 to 1\&.0 
.br
\fIwidth\fP width of viewport in range 0\&.0 to 1\&.0 
.br
\fIheight\fP height of viewport in range 0\&.0 to 1\&.0 
.RE
.PP
\fBReturns\fP
.RS 4
false: if it doesn't exist 
.PP
true: if succeed 
.RE
.PP

.SH "Member Data Documentation"
.PP 
.SS "std::unordered_map<std::string, \fBRenderCamera\fP*> me::RenderManager::mCameras\fC [protected]\fP"

.SS "Ogre::FileSystemLayer* me::RenderManager::mFSLayer\fC [protected]\fP"

.SS "\fBSGTechniqueResolverListener\fP* me::RenderManager::mMaterialMgrListener\fC [protected]\fP"

.SS "std::unordered_map<std::string, \fBRenderMesh\fP*> me::RenderManager::mMeshes\fC [protected]\fP"

.SS "std::string me::RenderManager::mOgreCfgPath\fC [protected]\fP"
Path of the 'Ogre\&.cfg' configuration file where it indicates all the configurations proposed for 'Renderer DirectX11' 
.SS "\fBRenderWindow\fP* me::RenderManager::mOgreWindow\fC [protected]\fP"

.SS "OverlayManager* me::RenderManager::mOverlayManager\fC [protected]\fP"

.SS "std::unordered_map<std::string, \fBRenderParticleSystem\fP*> me::RenderManager::mParticles\fC [protected]\fP"

.SS "std::string me::RenderManager::mPluginCfgPath\fC [protected]\fP"
Path of the 'plugins\&.cfg' Add all necessary \fBOgre\fP plugins in 'plugins\&.cfg' like this: Plugin=Codec_STBI Remember to add all the \&.dll of the written plugins 
.SS "std::string me::RenderManager::mResourceCfgPath\fC [protected]\fP"
Path of the 'resource\&.cfg' Add all resources (mesh, zip, particles, material, animation) to the subfolder of Asset And they are accessed by putting paths in 'resource\&.cfg' like this: Zip= \&.\&./\&.\&./Assets/packs/Sinbad\&.zip FileSystem=\&.\&./\&.\&./Assets/Main Be careful, our working directory is 'Exe/Main/', so we have to go to the above directory 2 times to access the 'Assets' directory\&. 
.SS "Ogre::Root* me::RenderManager::mRoot\fC [protected]\fP"

.SS "Ogre::RTShader::ShaderGenerator* me::RenderManager::mShaderGenerator\fC [protected]\fP"

.SS "Ogre::SceneManager* me::RenderManager::mSM = nullptr\fC [protected]\fP"

.SS "std::string me::RenderManager::mSolutionPath\fC [protected]\fP"

.SS "Ogre::AnimationState* me::RenderManager::ogreAnimState\fC [protected]\fP"


.SH "Author"
.PP 
Generated automatically by Doxygen for MotorEngine from the source code\&.
